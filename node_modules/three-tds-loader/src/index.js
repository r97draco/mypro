/*
 * Autodesk 3DS threee.js file loader, based on lib3ds.
 *
 * Loads geometry with uv and materials basic properties with texture support.
 *
 * @author @tentone
 * @author @timknip
 * @class TDSLoader
 * @constructor
 */

'use strict';

module.exports = function (THREE) {

  let M3DMAGIC = 0x4d4d;
  let MLIBMAGIC = 0x3daa;
  let CMAGIC = 0xc23d;
  let M3D_VERSION = 0x0002;
  let COLOR_F = 0x0010;
  let COLOR_24 = 0x0011;
  let LIN_COLOR_24 = 0x0012;
  let LIN_COLOR_F = 0x0013;
  let MDATA = 0x3d3d;
  let MESH_VERSION = 0x3d3e;
  let MASTER_SCALE = 0x0100;
  let MAT_ENTRY = 0xafff;
  let MAT_NAME = 0xa000;
  let MAT_AMBIENT = 0xa010;
  let MAT_DIFFUSE = 0xa020;
  let MAT_SPECULAR = 0xa030;
  let MAT_SHININESS = 0xa040;
  let MAT_TWO_SIDE = 0xa081;
  let MAT_ADDITIVE = 0xa083;
  let MAT_WIRE = 0xa085;
  let MAT_WIRE_SIZE = 0xa087;
  let MAT_TEXMAP = 0xa200;
  let MAT_OPACMAP = 0xa210;
  let MAT_BUMPMAP = 0xa230;
  let MAT_SPECMAP = 0xa204;
  let MAT_MAPNAME = 0xa300;
  let MAT_MAP_USCALE = 0xa354;
  let MAT_MAP_VSCALE = 0xa356;
  let MAT_MAP_UOFFSET = 0xa358;
  let MAT_MAP_VOFFSET = 0xa35a;
  let NAMED_OBJECT = 0x4000;
  let N_TRI_OBJECT = 0x4100;
  let POINT_ARRAY = 0x4110;
  let FACE_ARRAY = 0x4120;
  let MSH_MAT_GROUP = 0x4130;
  let TEX_VERTS = 0x4140;
  let MESH_MATRIX = 0x4160;

  THREE.TDSLoader = function ( manager ) {

    this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
    this.debug = false;

    this.group = null;
    this.position = 0;

    this.materials = [];
    this.meshes = [];

  };

  THREE.TDSLoader.prototype = {

    constructor: THREE.TDSLoader,

    /**
     * Load 3ds file from url.
     *
     * @method load
     * @param {[type]} url URL for the file.
     * @param {Function} onLoad onLoad callback, receives group Object3D as argument.
     * @param {Function} onProgress onProgress callback.
     * @param {Function} onError onError callback.
     */
    load: function ( url, onLoad, onProgress, onError ) {

      let scope = this;

      let path = this.path !== undefined ? this.path : THREE.LoaderUtils.extractUrlBase( url );

      let loader = new THREE.FileLoader( this.manager );

      loader.setResponseType( 'arraybuffer' );

      loader.load( url, function ( data ) {

        onLoad( scope.parse( data, path ) );

      }, onProgress, onError );

    },

    /**
     * Parse arraybuffer data and load 3ds file.
     *
     * @method parse
     * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.
     * @param {String} path Path for external resources.
     * @return {Object3D} Group loaded from 3ds file.
     */
    parse: function ( arraybuffer, path ) {

      this.group = new THREE.Group();
      this.position = 0;
      this.materials = [];
      this.meshes = [];

      this.readFile( arraybuffer, path );

      for ( let i = 0; i < this.meshes.length; i ++ ) {

        this.group.add( this.meshes[ i ] );

      }

      return this.group;

    },

    /**
     * Decode file content to read 3ds data.
     *
     * @method readFile
     * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.
     */
    readFile: function ( arraybuffer, path ) {

      let data = new DataView( arraybuffer );
      let chunk = this.readChunk( data );

      if ( chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC ) {

        let next = this.nextChunk( data, chunk );

        while ( next !== 0 ) {

          if ( next === M3D_VERSION ) {

            let version = this.readDWord( data );
            this.debugMessage( '3DS file version: ' + version );

          } else if ( next === MDATA ) {

            this.resetPosition( data );
            this.readMeshData( data, path );

          } else {

            this.debugMessage( 'Unknown main chunk: ' + next.toString( 16 ) );

          }

          next = this.nextChunk( data, chunk );

        }

      }

      this.debugMessage( 'Parsed ' + this.meshes.length + ' meshes' );

    },

    /**
     * Read mesh data chunk.
     *
     * @method readMeshData
     * @param {Dataview} data Dataview in use.
     */
    readMeshData: function ( data, path ) {

      let chunk = this.readChunk( data );
      let next = this.nextChunk( data, chunk );

      while ( next !== 0 ) {

        if ( next === MESH_VERSION ) {

          let version = + this.readDWord( data );
          this.debugMessage( 'Mesh Version: ' + version );

        } else if ( next === MASTER_SCALE ) {

          let scale = this.readFloat( data );
          this.debugMessage( 'Master scale: ' + scale );
          this.group.scale.set( scale, scale, scale );

        } else if ( next === NAMED_OBJECT ) {

          this.debugMessage( 'Named Object' );
          this.resetPosition( data );
          this.readNamedObject( data );

        } else if ( next === MAT_ENTRY ) {

          this.debugMessage( 'Material' );
          this.resetPosition( data );
          this.readMaterialEntry( data, path );

        } else {

          this.debugMessage( 'Unknown MDATA chunk: ' + next.toString( 16 ) );

        }

        next = this.nextChunk( data, chunk );

      }

    },

    /**
     * Read named object chunk.
     *
     * @method readNamedObject
     * @param {Dataview} data Dataview in use.
     */
    readNamedObject: function ( data ) {

      let chunk = this.readChunk( data );
      let name = this.readString( data, 64 );
      chunk.cur = this.position;

      let next = this.nextChunk( data, chunk );
      while ( next !== 0 ) {

        if ( next === N_TRI_OBJECT ) {

          this.resetPosition( data );
          let mesh = this.readMesh( data );
          mesh.name = name;
          this.meshes.push( mesh );

        } else {

          this.debugMessage( 'Unknown named object chunk: ' + next.toString( 16 ) );

        }

        next = this.nextChunk( data, chunk );

      }

      this.endChunk( chunk );

    },

    /**
     * Read material data chunk and add it to the material list.
     *
     * @method readMaterialEntry
     * @param {Dataview} data Dataview in use.
     */
    readMaterialEntry: function ( data, path ) {

      let chunk = this.readChunk( data );
      let next = this.nextChunk( data, chunk );
      let material = new THREE.MeshPhongMaterial();

      while ( next !== 0 ) {

        if ( next === MAT_NAME ) {

          material.name = this.readString( data, 64 );
          this.debugMessage( '   Name: ' + material.name );

        } else if ( next === MAT_WIRE ) {

          this.debugMessage( '   Wireframe' );
          material.wireframe = true;

        } else if ( next === MAT_WIRE_SIZE ) {

          let value = this.readByte( data );
          material.wireframeLinewidth = value;
          this.debugMessage( '   Wireframe Thickness: ' + value );

        } else if ( next === MAT_TWO_SIDE ) {

          material.side = THREE.DoubleSide;
          this.debugMessage( '   DoubleSided' );

        } else if ( next === MAT_ADDITIVE ) {

          this.debugMessage( '   Additive Blending' );
          material.blending = THREE.AdditiveBlending;

        } else if ( next === MAT_DIFFUSE ) {

          this.debugMessage( '   Diffuse Color' );
          material.color = this.readColor( data );

        } else if ( next === MAT_SPECULAR ) {

          this.debugMessage( '   Specular Color' );
          material.specular = this.readColor( data );

        } else if ( next === MAT_AMBIENT ) {

          this.debugMessage( '   Ambient color' );
          material.color = this.readColor( data );

        } else if ( next === MAT_SHININESS ) {

          let shininess = this.readWord( data );
          material.shininess = shininess;
          this.debugMessage( '   Shininess : ' + shininess );

        } else if ( next === MAT_TEXMAP ) {

          this.debugMessage( '   ColorMap' );
          this.resetPosition( data );
          material.map = this.readMap( data, path );

        } else if ( next === MAT_BUMPMAP ) {

          this.debugMessage( '   BumpMap' );
          this.resetPosition( data );
          material.bumpMap = this.readMap( data, path );

        } else if ( next === MAT_OPACMAP ) {

          this.debugMessage( '   OpacityMap' );
          this.resetPosition( data );
          material.alphaMap = this.readMap( data, path );

        } else if ( next === MAT_SPECMAP ) {

          this.debugMessage( '   SpecularMap' );
          this.resetPosition( data );
          material.specularMap = this.readMap( data, path );

        } else {

          this.debugMessage( '   Unknown material chunk: ' + next.toString( 16 ) );

        }

        next = this.nextChunk( data, chunk );

      }

      this.endChunk( chunk );

      this.materials[ material.name ] = material;

    },

    /**
     * Read mesh data chunk.
     *
     * @method readMesh
     * @param {Dataview} data Dataview in use.
     */
    readMesh: function ( data ) {

      let chunk = this.readChunk( data );
      let next = this.nextChunk( data, chunk );

      let useBufferGeometry = false;
      let geometry = null;
      let uvs = [];

      if ( useBufferGeometry ) {

        geometry = new THREE.BufferGeometry();

      }	else {

        geometry = new THREE.Geometry();

      }

      let material = new THREE.MeshPhongMaterial();
      let mesh = new THREE.Mesh( geometry, material );
      mesh.name = 'mesh';

      while ( next !== 0 ) {

        if ( next === POINT_ARRAY ) {

          let points = this.readWord( data );

          this.debugMessage( '   Vertex: ' + points );

          //BufferGeometry

          if ( useBufferGeometry )	{

            let vertices = [];
            for ( let i = 0; i < points; i ++ )		{

              vertices.push( this.readFloat( data ) );
              vertices.push( this.readFloat( data ) );
              vertices.push( this.readFloat( data ) );

            }

            geometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( vertices ), 3 ) );

          } else	{ //Geometry

            for ( let i = 0; i < points; i ++ )		{

              geometry.vertices.push( new THREE.Vector3( this.readFloat( data ), this.readFloat( data ), this.readFloat( data ) ) );

            }

          }

        } else if ( next === FACE_ARRAY ) {

          this.resetPosition( data );
          this.readFaceArray( data, mesh );

        } else if ( next === TEX_VERTS ) {

          let texels = this.readWord( data );

          this.debugMessage( '   UV: ' + texels );

          //BufferGeometry

          if ( useBufferGeometry )	{

            let uvs = [];
            for ( let i = 0; i < texels; i ++ )		{

              uvs.push( this.readFloat( data ) );
              uvs.push( this.readFloat( data ) );

            }
            geometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( uvs ), 2 ) );

          } else { //Geometry

            uvs = [];
            for ( let i = 0; i < texels; i ++ )		{

              uvs.push( new THREE.Vector2( this.readFloat( data ), this.readFloat( data ) ) );

            }

          }

        } else if ( next === MESH_MATRIX ) {

          this.debugMessage( '   Tranformation Matrix (TODO)' );

          let values = [];
          for ( let i = 0; i < 12; i ++ ) {

            values[ i ] = this.readFloat( data );

          }

          let matrix = new THREE.Matrix4();

          //X Line
          matrix.elements[ 0 ] = values[ 0 ];
          matrix.elements[ 1 ] = values[ 6 ];
          matrix.elements[ 2 ] = values[ 3 ];
          matrix.elements[ 3 ] = values[ 9 ];

          //Y Line
          matrix.elements[ 4 ] = values[ 2 ];
          matrix.elements[ 5 ] = values[ 8 ];
          matrix.elements[ 6 ] = values[ 5 ];
          matrix.elements[ 7 ] = values[ 11 ];

          //Z Line
          matrix.elements[ 8 ] = values[ 1 ];
          matrix.elements[ 9 ] = values[ 7 ];
          matrix.elements[ 10 ] = values[ 4 ];
          matrix.elements[ 11 ] = values[ 10 ];

          //W Line
          matrix.elements[ 12 ] = 0;
          matrix.elements[ 13 ] = 0;
          matrix.elements[ 14 ] = 0;
          matrix.elements[ 15 ] = 1;

          matrix.transpose();

          let inverse = new THREE.Matrix4();
          inverse.getInverse( matrix, true );
          geometry.applyMatrix( inverse );

          matrix.decompose( mesh.position, mesh.quaternion, mesh.scale );

        } else {

          this.debugMessage( '   Unknown mesh chunk: ' + next.toString( 16 ) );

        }

        next = this.nextChunk( data, chunk );

      }

      this.endChunk( chunk );

      if ( ! useBufferGeometry ) {

        //geometry.faceVertexUvs[0][faceIndex][vertexIndex]

        if ( uvs.length > 0 ) {

          let faceUV = [];

          for ( let i = 0; i < geometry.faces.length; i ++ ) {

            faceUV.push( [ uvs[ geometry.faces[ i ].a ], uvs[ geometry.faces[ i ].b ], uvs[ geometry.faces[ i ].c ] ] );

          }

          geometry.faceVertexUvs[ 0 ] = faceUV;

        }

        geometry.computeVertexNormals();

      }

      return mesh;

    },

    /**
     * Read face array data chunk.
     *
     * @method readFaceArray
     * @param {Dataview} data Dataview in use.
     * @param {Mesh} mesh Mesh to be filled with the data read.
     */
    readFaceArray: function ( data, mesh ) {

      let chunk = this.readChunk( data );
      let faces = this.readWord( data );

      this.debugMessage( '   Faces: ' + faces );

      for ( let i = 0; i < faces; ++ i ) {

        mesh.geometry.faces.push( new THREE.Face3( this.readWord( data ), this.readWord( data ), this.readWord( data ) ) );

      }

      //The rest of the FACE_ARRAY chunk is subchunks

      while ( this.position < chunk.end ) {

        let chunk = this.readChunk( data );

        if ( chunk.id === MSH_MAT_GROUP ) {

          this.debugMessage( '      Material Group' );

          this.resetPosition( data );

          let group = this.readMaterialGroup( data );

          let material = this.materials[ group.name ];

          if ( material !== undefined )	{

            mesh.material = material;

            if ( material.name === '' )		{

              material.name = mesh.name;

            }

          }

        } else {

          this.debugMessage( '      Unknown face array chunk: ' + chunk.toString( 16 ) );

        }

        this.endChunk( chunk );

      }

      this.endChunk( chunk );

    },

    /**
     * Read texture map data chunk.
     *
     * @method readMap
     * @param {Dataview} data Dataview in use.
     * @return {Texture} Texture read from this data chunk.
     */
    readMap: function ( data, path ) {

      let chunk = this.readChunk( data );
      let next = this.nextChunk( data, chunk );
      let texture = {};

      let loader = new THREE.TextureLoader( this.manager );
      loader.setPath( path );

      while ( next !== 0 ) {

        if ( next === MAT_MAPNAME ) {

          let name = this.readString( data, 128 );
          texture = loader.load( name );

          this.debugMessage( '      File: ' + path + name );

        } else if ( next === MAT_MAP_UOFFSET ) {

          texture.offset.x = this.readFloat( data );
          this.debugMessage( '      OffsetX: ' + texture.offset.x );

        } else if ( next === MAT_MAP_VOFFSET ) {

          texture.offset.y = this.readFloat( data );
          this.debugMessage( '      OffsetY: ' + texture.offset.y );

        } else if ( next === MAT_MAP_USCALE ) {

          texture.repeat.x = this.readFloat( data );
          this.debugMessage( '      RepeatX: ' + texture.repeat.x );

        } else if ( next === MAT_MAP_VSCALE ) {

          texture.repeat.y = this.readFloat( data );
          this.debugMessage( '      RepeatY: ' + texture.repeat.y );

        } else {

          this.debugMessage( '      Unknown map chunk: ' + next.toString( 16 ) );

        }

        next = this.nextChunk( data, chunk );

      }

      this.endChunk( chunk );

      return texture;

    },

    /**
     * Read material group data chunk.
     *
     * @method readMaterialGroup
     * @param {Dataview} data Dataview in use.
     * @return {Object} Object with name and index of the object.
     */
    readMaterialGroup: function ( data ) {

      let name = this.readString( data, 64 );
      let numFaces = this.readWord( data );

      this.debugMessage( '         Name: ' + name );
      this.debugMessage( '         Faces: ' + numFaces );

      let index = [];
      for ( let i = 0; i < numFaces; ++ i ) {

        index.push( this.readWord( data ) );

      }

      return { name: name, index: index };

    },

    /**
     * Read a color value.
     *
     * @method readColor
     * @param {DataView} data Dataview.
     * @return {Color} Color value read..
     */
    readColor: function ( data ) {

      let chunk = this.readChunk( data );
      let color = new THREE.Color();

      if ( chunk.id === COLOR_24 || chunk.id === LIN_COLOR_24 ) {

        let r = this.readByte( data );
        let g = this.readByte( data );
        let b = this.readByte( data );

        color.setRGB( r / 255, g / 255, b / 255 );

        this.debugMessage( '      Color: ' + color.r + ', ' + color.g + ', ' + color.b );

      }	else if ( chunk.id === COLOR_F || chunk.id === LIN_COLOR_F ) {

        let r = this.readFloat( data );
        let g = this.readFloat( data );
        let b = this.readFloat( data );

        color.setRGB( r, g, b );

        this.debugMessage( '      Color: ' + color.r + ', ' + color.g + ', ' + color.b );

      }	else {

        this.debugMessage( '      Unknown color chunk: ' + chunk.toString( 16 ) );

      }

      this.endChunk( chunk );
      return color;

    },

    /**
     * Read next chunk of data.
     *
     * @method readChunk
     * @param {DataView} data Dataview.
     * @return {Object} Chunk of data read.
     */
    readChunk: function ( data ) {

      let chunk = {};

      chunk.cur = this.position;
      chunk.id = this.readWord( data );
      chunk.size = this.readDWord( data );
      chunk.end = chunk.cur + chunk.size;
      chunk.cur += 6;

      return chunk;

    },

    /**
     * Set position to the end of the current chunk of data.
     *
     * @method endChunk
     * @param {Object} chunk Data chunk.
     */
    endChunk: function ( chunk ) {

      this.position = chunk.end;

    },

    /**
     * Move to the next data chunk.
     *
     * @method nextChunk
     * @param {DataView} data Dataview.
     * @param {Object} chunk Data chunk.
     */
    nextChunk: function ( data, chunk ) {

      if ( chunk.cur >= chunk.end ) {

        return 0;

      }

      this.position = chunk.cur;

      try {

        let next = this.readChunk( data );
        chunk.cur += next.size;
        return next.id;

      }	catch ( e ) {

        this.debugMessage( 'Unable to read chunk at ' + this.position );
        return 0;

      }

    },

    /**
     * Reset dataview position.
     *
     * @method resetPosition
     * @param {DataView} data Dataview.
     */
    resetPosition: function () {

      this.position -= 6;

    },

    /**
     * Read byte value.
     *
     * @method readByte
     * @param {DataView} data Dataview to read data from.
     * @return {Number} Data read from the dataview.
     */
    readByte: function ( data ) {

      let v = data.getUint8( this.position, true );
      this.position += 1;
      return v;

    },

    /**
     * Read 32 bit float value.
     *
     * @method readFloat
     * @param {DataView} data Dataview to read data from.
     * @return {Number} Data read from the dataview.
     */
    readFloat: function ( data ) {

      try {

        let v = data.getFloat32( this.position, true );
        this.position += 4;
        return v;

      }	catch ( e ) {

        this.debugMessage( e + ' ' + this.position + ' ' + data.byteLength );

      }

    },

    /**
     * Read 32 bit signed integer value.
     *
     * @method readInt
     * @param {DataView} data Dataview to read data from.
     * @return {Number} Data read from the dataview.
     */
    readInt: function ( data ) {

      let v = data.getInt32( this.position, true );
      this.position += 4;
      return v;

    },

    /**
     * Read 16 bit signed integer value.
     *
     * @method readShort
     * @param {DataView} data Dataview to read data from.
     * @return {Number} Data read from the dataview.
     */
    readShort: function ( data ) {

      let v = data.getInt16( this.position, true );
      this.position += 2;
      return v;

    },

    /**
     * Read 64 bit unsigned integer value.
     *
     * @method readDWord
     * @param {DataView} data Dataview to read data from.
     * @return {Number} Data read from the dataview.
     */
    readDWord: function ( data ) {

      let v = data.getUint32( this.position, true );
      this.position += 4;
      return v;

    },

    /**
     * Read 32 bit unsigned integer value.
     *
     * @method readWord
     * @param {DataView} data Dataview to read data from.
     * @return {Number} Data read from the dataview.
     */
    readWord: function ( data ) {

      let v = data.getUint16( this.position, true );
      this.position += 2;
      return v;

    },

    /**
     * Read string value.
     *
     * @method readString
     * @param {DataView} data Dataview to read data from.
     * @param {Number} maxLength Max size of the string to be read.
     * @return {String} Data read from the dataview.
     */
    readString: function ( data, maxLength ) {

      let s = '';

      for ( let i = 0; i < maxLength; i ++ ) {

        let c = this.readByte( data );
        if ( ! c ) {

          break;

        }

        s += String.fromCharCode( c );

      }

      return s;

    },

    /**
     * Set resource path used to determine the file path to attached resources.
     *
     * @method setPath
     * @param {String} path Path to resources.
     * @return Self for chaining.
     */
    setPath: function ( path ) {

      this.path = path;

      return this;

    },

    /**
     * Print debug message to the console.
     *
     * Is controlled by a flag to show or hide debug messages.
     *
     * @method debugMessage
     * @param {Object} message Debug message to print to the console.
     */
    debugMessage: function ( message ) {

      if ( this.debug ) {

        console.log( message );

      }

    }
  };

  return THREE.TDSLoader;
};